---
layout: post
title:  "shell"
date:   2020-09-24 18:52:18 +0800
categorie: jekyll
---

#### 一、文本处理工具

 1、grep

- grep是行过滤工具，用于根据关键字进行过滤

 1）语法和选项：

- 语法：

```
grep [选项] ‘关键字’ 文件名
```

- 常见选项：

```
option：

	-i：不区分大小写

	-v：查找不包含指定内容的行，反向选择

	-w：按单词搜索

	-o：打印匹配关键字

	-c：统计匹配到的次数

	-n：统计匹配到的行数

	-r：逐层遍历目录查找

	-A：显示匹配行及后面多少行

	-B：显示匹配行及前面多少行

	-C：显示匹配行前后多少行    #查看日志时，只匹配”error“看不出哪里出错，需要看上下文

	-l：只列出匹配的文件名

	-L：只列出不匹配的文件名

	-e：使用正则匹配

	-E：使用扩展正则匹配

	--color=auto：可以将找到的关键字部分加上颜色的显示
```

 2、cut

- cut是列截取工具，用于列的截取

 1）语法和选项：

- 语法：

```
cut [选项] 文件名
```

- 常见选项：

```
option：

	-c：以字符为单位进行分割

	-d：自定义分隔符，默认为制表符\t

	-f：与-d一起使用，指定截取哪个区域
	#-f1，7：显示第一字段和第七字段
```

 3、sort

- sort工具用于排序，它将文件中的每一行作为一个单位，从首字符向后，依次按ASCII码进行比较，最后将他们按升序输出

 1）语法和选项：

- 语法：

```
sort [OPTION]... [FILE]... 
```

- 选项：

```
option：

	-u：去除重复行

	-r：降序排列，默认是升序	

	-o：将排序结果输出到文件中，类似重定向符号>

	-n：以数字排序，默认是按字符排序

	-t：分隔符

	-k：第N列

	-b：忽略前导空格

	-R：随机排序，每次运行的结果均不同
```

 4、uniq

- uniq用于去除连续的重复行

 1）语法与选项：

- 语法：

```
uniq [OPTION]... [INPUT [OUTPUT]]
```

- 常见选项：

```
option：

	-i：忽略大小写

	-c：统计重复行次数

	-d：只显示重复行
```

 5、tee

- tee工具从标准输入读取并写入到标准输出和文件，即：双向覆盖重定向（屏幕输出---->文本输入）


 1）语法与选项：

- 选项：

```
options：

	-a：双向追加重定向
```

 6、diff

- diff工具用于逐行比较文件的不同

注：diff描述两个文件不同方式是告诉我们怎样改变第一个文件之后与第二个文件匹配

 1）语法与选项：

- 语法：

```
diff [选项] 文件1 文件2
```

- 常用选项：

```
options：

	-b：不检查空格

	-B：不检查空白行

	-i：不检查大小写

	-W：忽略所有的空格

	--normal：正常格式显示

	-c：上下文格式显示

	-u：合并格式显示
```

 2）三种显示格式：

- 正常显示

- 上下文显示

- 合并格式

 3）补丁小技巧：

- 有时候我们需要以一个文化为标准，去修改其他文件，并且修改的地方较多，我们可以通过打补丁的方式完成

```
先找出文件的不同，然后输出到一个文件

diff -uN file1 file2 > file.patch

#-u：上下文模式

#-N：将不存在的文件当作空文件

将不同的内容打补丁到文件

patch file1 file.patch

测试验证
```

 7、paste

- paste工具用于合并文件行

 1）语法与选项：

- 常用选项：

```
options：

	-d：自定义间隔符，默认是tab

	-s：串行处理，并非行
```

 8、tr

- tr用户字符转换、替换和删除，主要用于删除文件中控制字符或进行字符转换

 1）语法和选项：

- 语法：

```
tr [option] 'sting1' 'string2'
```

- 语法解析：
  - 命令的执行结果交给tr处理，其中string1用于查询，strng2用于转换处理
  - tr处理的内容来自文件，记住要使用‘<’标准输入
  - 匹配string进行相应操作，如删除操作

#### 二、命令和文件的自动补全

- tab键只能不全命令和文件

 1、常见的快捷键

- `ctrl+c`：终止前台运行的程序

- `ctrl+z`：把前台运行的程序挂到后台

- `ctrl+d`：退出，等价于exit

- `ctrl+l`：清屏

- `ctrl+a`：将光标移到命令行最前端

- `ctrl+e`：光标移到命令行最后端

- `ctrl+u`：删光光标前所有字符

- `ctrl+k`：删除光标后所有字符

- `ctrl+r`：搜索历史命令

 2、常用通配符

- `*`：匹配0或多个任意字符

- `?`：匹配任意单个字符

- `[ ]`：匹配[list]中的任意单个字符

- `[^ ]`：匹配除list中的任意单个字符

- `[- ]`：匹配中括号中任意一个字符，- 代表一个范围。例如，[a-z] 代表匹配一个小写字母

- `{string1,string2,string3...}`：匹配string1，string2，string3或更多字符串

```
eg：ls -l file{1..13}.jpg

#匹配数字：1-13

eg：ls -l file[1-13].jpg

#匹配数字：1-1和3

#出现的结果只有：file1.jpg，file3.jpg
```

 3、bash中的引号

- `“”`：双引号，会把引号的内容当作整体来看待，允许通过$符号引用其他变量值

- `‘’`：单引号，会把引号的内容当成整体来看待，禁止引用其他变量值，shell中特殊符号都被设为普通字符

- ``:反撇号和$()一样，引号或者括号里的命令会优先执行，如果存在嵌套，反撇号不能用

#### 三、shell学习

 1、前言：

- 计算机只能识别机器语言（0和1），但是程序员不难直接去写0和1这样的代码，所以要想将程序员开发的代码在计算机上运行，就需要编译器或解释器来将代码翻译成计算机语言

 2、编程语言分类:

- 编译型语言：

- 在程序执行之前需要一个专用的编译过程，把程序编译成为机器语言文件，运行时不需要重新翻译，直接使用编译的结果就行，程序执行效率高，依赖编译器，跨平台性差

- 解释性语言：

- 程序不需要编译，程序在运行时由解释器翻译成机器语言，每执行一次都要翻译一次，因此效率比较低

 3、shell的种类：

```
[root@aliyun ~]# cat /etc/shells

/bin/sh          #是bash的一个快捷方式

/bin/bash        #bash是大多数linux默认的shell，包含的功能几乎可以涵盖shell所有的功能

/sbin/nologin    #表示非交互，不能登陆操作系统

/bin/dash        #小巧，高效，功能相对少一些

/usr/bin/sh      

/usr/bin/bash
```

 4、shell脚本

- 简单来说，就是将需要执行的命令保存到文本中，按照顺序执行，它是解释型的，意味着不需要编译

 5、shell脚本的作用

1）自动化软件部署

2）自动化管理：系统初始化脚本、批量更改主机密码、推送公钥

3）自动分析：统计网站访问量

4）自动化备份：数据库备份、日志转储

5）自动化监控脚本

 6、shell脚本的基本语法

1）脚本第一行，‘#！’指定解释器

- `#!/bin/bash`：表示一下内容使用bash解释器解析
- `#!/bin/env 解释器`：如果直接将解释器路径写死在脚本中，可能在某些系统就会存在找不到解释器的兼容性问题，env是个Linux命令，它会按照当前环境变量设置（主要是PATH变量），查找名为python的可执行文件

2）脚本的第二部分，‘#’后面的内容是对脚本的基本信息进行描述

 7、shell脚本的执行方法

- 标准脚本执行方法

```
chmod +x xxx.sh

/xxx/xxx/xxx.sh
```

- 非标准

```
bash xxx.sh

bash +x xxx.sh     #一般用于排错，查看脚本的执行过程

bash +n xxx.sh     #查看脚本是否有语法错误
```

#### 四、变量

 1、什么是变量

- 变量是用来临时保存数据，该数据是可以变化的数据

 2、定义变量

1）变量名=变量值

- #取消变量：`unset 变量名`

2）命令的执行结果赋值给变量

```
A=`hostname`

A=$（echo hello_word）
```

3）交互式定义变量（read）

```
#用户自己定义变量

read [选项] 变量名

#变量来自于文件

read [选项] 变量名 < filename
```

- 常见选项：

| 选项 | 释义                       |
| ---- | -------------------------- |
| -p   | 定义提示用户的信息         |
| -n   | 定义字符数                 |
| -s   | 不显示                     |
| -t   | 定义超过时间，默认单位为秒 |

4）定义有类型的变量（declare）

- 目的：给一些变量做一些限制，固定变量的类型，比如：整型、只读

- 用法：

```
declare [选项] 变量名=变量值
```

- 常见选项：

| 选项 | 释义                       | 举例                 |
| ---- | -------------------------- | -------------------- |
| -i   | 将变量看成整数             | declare -i A=123     |
| -r   | 定义只读变量               | declare -r B=hello   |
| -a   | 定义普通数组，查看普通数组 |                      |
| -A   | 定义关联数组，查看关联数组 |                      |
| -x   | 将变量通过环境导出         | delare -x AAA=123456 |

 3、变量规则：

1）变量区分大小写

2）变量名不能有特殊符号，变量不能有空格

3）变量名不能以数字开头

4）等号两边不能有空格

5）变量名尽量做到见名知意

 4、变量的分类：

1）本地变量

- 当前用户自定义的变量，当前进程中有效，其他进程及当前进程的子进程无效

2）环境变量

- 当前进程有效，并且能够被子进程调用

- env：查看当前用户的环境变量
- set：查询当前用户的所有变量（临时变量和环境变量）
- export：`变量名=变量值`，或者`变量名=变量值；export`

```
#临时将一个本地变量变成环境变量

export A=hello

#永久生效

vim /etc/profile 

vim ~/bashrc
```

3）全局变量

- 全局所有的用户和程序都都能调用，且继承，新建的用户也默认能调用

- 相关配置文件：以上文件修改后，都需要重新source让其生效或者退出重新登陆

| 文件名          | 说明                               | 备注                       |
| --------------- | ---------------------------------- | -------------------------- |
| ~/.bashrc       | 当前用户的bash信息，用于登陆时读取 | 定义别名、umask、函数等    |
| ~/.bash_profile | 当前用户的环境变量                 |                            |
| ~/.bash_logout  | 当前用户退出当前shell时最后读取    | 定义用户退出时执行的程序等 |
| /etc/bashrc     | 全局的bash信息，所有用户都生效     |                            |
| /etc/profile    | 全局环境变量信息                   | 系统和所有用户都生效       |

- 用户登陆系统读取相关文件的顺序：
  - `/etc/profile`
  - `~/.bash_profile`
  - `~/.bashrc`
  - `/etc/bashrc`
  - `~/.bash_logout`

4）系统变量

- 内置bash中变量：shell本身已经固定好它的名字和作用

| 内置变量   | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| $?         | 上一条命令执行后返回的状态，0：执行正常，非0：执行异常或错误 |
| $0         | 当前执行的程序或脚本名                                       |
| $#         | 脚本后面接的参数的个数                                       |
| $*         | 脚本后面所有参数，参数当作一个整体输出，每一个变量参数之间以空格隔开 |
| $@         | 脚本后面所有参数，参数是独立的，也是全部输出                 |
| $1-$9      | 脚本后面的位置参数，$1表示第一个位置参数                     |
| ${10}-${n} | 扩展位置参数，第10个位置变量必须用{}括起来（2位数以上括起来） |
| $$         | 当前所在进程的进程号，如echo $$                              |
| $!         | 后台运行的最后一个进程号（当前终端）                         |
| !$         | 调用最后一条命令历史中的参数                                 |

#### 五、简单四则运算符号

- 算术运算：默认情况下，shell就只能支持简单的整数运算

- 运算内容：加（+）、减（-）、乘（*）、除（/）、求余数（%）

- 四则运算符号：

| 表达式 | 举例          |
| ------ | ------------- |
| $(( )) | echo $((1+1)) |
| $[ ]   | echo $[10-5]  |
| expr   | expr 10 / 5   |
| let    | n-1;let n+=1  |

#### 六、条件判断语法结构

 1、条件判断语法格式：

- 格式1：test 条件表达式
- 格式2：[ 条件表达式 ]
- 格式3：[[ 条件表达式 ]]，支持正则

 2、判断参数

- 判断文件类型：

| 判断参数 | 含义                                         |
| -------- | -------------------------------------------- |
| -e       | 判断文件是否存在                             |
| -f       | 判断文件是否存在并且是一个普通文件           |
| -d       | 判断文件是否存在并且是一个目录               |
| -b       | 判断文件是否存在并且是一个块设备             |
| -L       | 判断文件是否存在并且是一个软链接文件         |
| -S       | 判断文件是否存在并且是一个套接字设备         |
| -c       | 判断文件是否存在并且是一个字符设备文件       |
| -p       | 判断文件是否存在并且是一个命名管道文件       |
| -s       | 判断文件是否存在并且是一个非空文件（有内容） |

- 判断文件权限

| 判断参数 | 含义               |
| -------- | ------------------ |
| -r       | 当前用户是否可读   |
| -w       | 当前用户是否可写   |
| -x       | 当前用户是否可执行 |
| -u       | 是否有suid         |
| -g       | 是否有sgid         |
| -k       | 是否有t位          |

- 判断整数

| 判断参数 | 含义     |
| -------- | -------- |
| -eq      | 相等     |
| -ne      | 不相等   |
| -gt      | 大于     |
| -ge      | 大于等于 |
| -lt      | 小于     |
| -le      | 小于等于 |

- 判断字符串

| 判断参数          | 含义                                    |
| ----------------- | --------------------------------------- |
| -z                | 判断是否为空字符，字符长度为0成立       |
| -n                | 判断是否为非空字符，字符长度不为0则成立 |
| string1 = string2 | 判断字符串是否相等                      |
| string1 !=string2 | 判断字符串是否不相等                    |

- 多重条件判断

| 判断符号 | 含义   | 举例                                               |
| -------- | ------ | -------------------------------------------------- |
| -a和&&   | 逻辑与 | [ 1 -eq 1 -a 1 -ne 0 ]或[ 1 -eq 1 ]&&[ 0 -ne 1 ]   |
| -o和\|\| | 逻辑或 | [ 1 -eq 1 -o 0 -ne 1 ]或[ 1 -eq 1 ]\|\|[ 0 -ne 1 ] |

- 注：
  - `&&`：前面的表达式为真，才会执行后面的代码
  - `||`：前面的表达式为假，才会执行后面的代码
  - ；：只用于分割命令或表达式

 3、类c风格的数值比较：

- 注：在(( ))中，=表示赋值，==表示判断

```
eg：

(( 1==2 ))；echo $?

字符串判断：

注：

双括号引起来，看作是一个整体；=、==都表示判断

eg：

a=‘hello’;b='word';[ "$a" = "&b" ];echo $?

[ "$a" != "&b" ];echo $?
```

#### 七、流程控制语句

 1、基本语法结构：

- if

```
方式1：

if [ condition ];then

	command

	command

fi

方式2：

[ condition ] && command
```

- if……else：

```
if [ condition ];then

		command1

	else

		command2

fi

--------------------------------------------------------------------------------------

[ condition ] && command1 || command2
```

- if……elif……else：

```
if [ condition1 ];then

		command1

	elif [ condition2 ];then

		command2

	else

		command3

fi
```

#### 八、for循环语句：

 1、基本语法结构：

- 列表for循环：用于将一组命令执行已知的次数

 2、循环参数：

1）基本语法格式：

- 带列表

```
for variable in {list}

	do

		command

		command

	done

------------------------------

for variable in a b c

	do

		command

		command

	done

------------------------------
	
for variable in $(seq 5)

	do

		command

		command

	done
	
-------------------------------

需要另外记忆的：

seq 10            #输出0-10
seq 10 -1 1       #输出10、9、8……0
{1..10..2}        #输出1、3、5……9
{1..10}           #输出1-10
{10..1}           #输出10、9、8……1
```

- 不带列表：

- 基本语法格式：

```
for variable

	do

		command

		command

	done
	
-------------------------------------------
	
eg：

#!/bin/bash

#文件名为for_test.sh

for i
	do
		echo "hello"
	done

[root@aliyun ~]# bash -x for_test.sh a 
+ for i in '"$@"'
+echo hello
hello
```

 2、类c风格的for循环：

- 基本语法结构：

```
#expr1:定义变量并赋初值

#expr2:决定是否进行循环（条件）

#expr3:决定循环变量如何改变，决定循环什么时候退出

for(( expr1;expr2;expr3 ))

	do

		command

		command

	done

eg：

for (( i=1;i<=5;i++ ))

	do

		echo $i

	done
```

 3、contiune、break和exit之间的区别

- continue：继续，表示循环体内（do……done之间）下面的代码不执行，重新开始下一次循环
- break：打断；马上停止执行本次循环，执行循环体后面的代码
- exit：表示直接跳出程序

#### 九、while循环语句

- 条件为真就进入循环，条件为假就退出循环

 1、基本语法结构：

```
while 表达式

 	do

		command

	done
```

#### 十、until

 1、基本概念：

- 条件为假就进入循环，条件为真就退出循环

 2、until语法结构

```
until 表达式

	do

		command

		command

	done
```

#### 十一、case

 1、基本概念：

- case语句为多重匹配语句

- 如果匹配成功，执行相匹配的命令

 2、语法结构：

```
case var in

pattern 1)                              #用“|”分割多个模式，相当于or，eg:hello|word)

	command1

	;;                                  #;;两个分号代表命令结束

pattern 2)

	command2

	;;

		*)                        #default，不满足以上模式，默认执行下面的语句

	command4

	;;
esac                                    #exac表示case语句结束
```

#### 十二、函数

 1、什么是函数

- shell运行将一组命令集合或语句形成一段可用代码，这些代码块称为shell函数

- 给这段代码起个名字（函数名），后续可用直接调用这段代码的功能

 2、如何定义函数

```
方法1：

函数名（）
{
	函数体
}

方法2：

function 函数名（）
{
	函数体
}
```

 3、函数调用方式：

```
functionname
```

 4、函数中return说明：

1）return可用结束一个函数，类似于循环控制语句break（结束当前循环，执行循环体后面的代码）

2）return默认返回函数中最后一个命令状态值，也可以给定参数值，范围是0-256之间

3）如果没有return函数，函数将返回最后一个指令的退出状态值

#### 十三、正则表达式

 1、正则表达式概念：

- Regular Expression、regex、regexp，常规表示法，是一种字符模式，用于在查找过程中匹配指定的字符

 2、正则当中名词解释：

- 元字符：指那些在正则表达式中具有特殊意义的专用字符，如点（.），星（*），问号（？）等

- 前导字符：位于元字符前面的字符，ab==c==*

- 第一类正则表达式：：正则中普通常用的元字符：

 3、元字符：

- 常见元字符

| 元字符 | 功能                                         |
| ------ | -------------------------------------------- |
| .      | 匹配除了换行符以外的任意单个字符             |
| *      | 前导字符出现0次或连续多次                    |
| .*     | 任意长度字符                                 |
| ^      | 行首以……开头                                 |
| $      | 行尾以……结尾                                 |
| ^$     | 空行                                         |
| [ ]    | 匹配括号里任意单个字符或一组单个字符         |
| [^ ]   | 匹配不包含括号里任一单个字符或一组字符       |
| ^[ ]   | 匹配以括号里任意单个字符或一组单个字符开头   |
| ^[^]   | 匹配不以括号里任意单个字符或一组单个字符开头 |

- 正则中其他常用元字符：

| 元字符    | 功能                                | 举例 |
| --------- | ----------------------------------- | ---- |
| \ <       | 取单词的头(\和<不空格)              |      |
| \ >       | 取单词的尾(\和>不空行格)            |      |
| \ < \ >   | 精确匹配                            |      |
| \ {n\ }   | 匹配前导字符连续出现n次             |      |
| \ {n,m\ } | 匹配前导字符出现n次与m次之间        |      |
| \ ( \ )   | 保存被匹配的字符                    |      |
| \d        | 匹配数字（eg：grep -P '\d' 1.txt）  |      |
| \w        | 匹配字母数字下划线（grep -P）       |      |
| \s        | 匹配空行、制表符、换页符（grep -P） |      |

- 扩展类正则常用元字符：
  - grep -E或者是egrep才能接扩展类正则常用元字符
  - sed -r才能接扩展类正则常用元字符

| 扩展元字符 | 功能                   | 举例                             |
| ---------- | ---------------------- | -------------------------------- |
| +          | 匹配一个或多个前导字符 | bo+：匹配boo、bo                 |
| ？         | 匹配零个或一个前导字符 | bo?：匹配b、bo                   |
| \|         | 或                     | a\|b：匹配a或b                   |
| ()         | 组字符，看成整体       | (my\|your)self：myself或yourself |
| {n}        | 前导字符重复n次        |                                  |
| {n,}       | 前导字符重复至少n次    |                                  |
| {n,m}      | 前导字符重复n到m次     |                                  |

 4、第二类正则

| 表达式    | 功能                         |
| --------- | ---------------------------- |
| [:alnum:] | 字母与数字                   |
| [:alpha:] | 大小写字母                   |
| [:blank:] | 空格和制表符                 |
| [:digit:] | 数字                         |
| [:lower:] | 小写字母                     |
| [:upper:] | 大写字母                     |
| [:punct:] | 标点符号                     |
| [:space:] | 换行符、回车等在内的所有空白 |

#### 十四、任务

 1、自动化创建用户

- 使用shell脚本完成批量添加系统用户功能，如添加的用户名称类似: user01、user02、user03到user10 ，并且自动设置这些用户的密码为随机字母加数字18位，最终脚本输出行类似为：user01 01abccc22233aa..18位

1）脚本内容

```
#!/bin/bash

function key()
{       
        key='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
        num=${#key}
        password=''

        for i in $(seq 18)
         do
                n=$[RANDOM%num]
                password=$password${key:$n:1}
         done
    
        echo $password

}


for i in $(seq 10)
 do
        if [ $i -lt 10 ];then
                useradd user0$i
                echo user0$i `key` >> ~/user_key
                head -`echo $i` ~/user_key|tail -1|cut -d' ' -f2|passwd user0$i
        else
                useradd user10
                echo user10 `key` >> ~/user_key
                head -10 ~/user_key|tail -1|cut -d' ' -f2|passwd user10
        fi
 done
```

2）~/user_key输出结果

```
[root@aliyun ~]# cat user_key 

user01 ofpe6Y38EoFU1kh0Xy
user02 OREbU6PxKxIWXQPbNj
user03 7A9foLCQ5OSOAyrllb
user04 q04zkj3dM5UMXpaqgz
user05 qUJdTfz04KbDaUyQed
user06 cd0cLH7st79yWUIMZJ
user07 WxXeyCQmAO6T47DZes
user08 0REVJ02XasEudl22TM
user09 ruaanLLoziRLEK3JGN
user10 3CdyWE9Q5l1UbFqjAt
```

 2、找序列的第50位数

- 使用shell脚本完成给出序列[1,1,2,3,5,8,13,21,...]输出第50个数

1）脚本内容

```
#!/bin/bash

a=1
b=1

for (( i=1;i<=24;i++ ))
 do
        let a=$a+$b
        let b=$b+$a
 done

echo "第50个数为：$b"
```

2）输出结果

```
[root@aliyun ~]# ./num.sh 

第50个数为：12586269025
```

